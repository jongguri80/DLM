# This code demonstrates how to fit the DLMs in the paper
# "Distributed Lag Models: Examining Associations between the Built environment and Health" 
# by Baek et al.

# The code below is in two stages:
# (1) R functions used to fit the DLM which follows closely the notations used in the eAppendix for the paper.
# (2) an example of how to use these functions to fit and plot outputs from the DLM

 
############################ Part 1: R Functions to fit DLM ########################
####################################################################################

LagFunc = function(Lag){
# This function calculates a cubic radial basis function which transformed for parameter estimation.
# For more details, please see the second paragraph in the estimation section of eAppendix. 
# The input for this function is a vector or distances r_1, r_2,..., r_L
# The outputs of the function are several matrices/vectors needed in other functions below

			### center lags at its mean to improve stability for models ###
			Lag_ct = Lag - mean(Lag)
			L = length(Lag)
			## calculate a natural cubic radial basis ##
			C0 = cbind(rep(1, L), Lag_ct)
			C1 = matrix(nrow = L, ncol = L)
			for(i in 1:L)for(j in 1:L) C1[i,j] = abs(Lag_ct[i] - Lag_ct[j])^3

			## to get matrix M1 and M2 ##
			qr_Q = qr.Q(qr(cbind(C0, C1)))
			M1 = qr_Q[,-c(1,2)] ## M1 is orthogonal matrix to C0.
			M2 = t(M1) %*% C1 %*% M1
			inv_M2_sqrt = svd(M2)$v %*% diag(1/sqrt(svd(M2)$d)) %*% t(svd(M2)$u)
			Omg = cbind(C0, C1 %*% M1 %*% inv_M2_sqrt)
			
## C0, C1 %*% M1 %*% inv_M2_sqrt, and Omg are the same matrix used in the third paragraph in the estimation section of eAppendix.
			return(list(Lag = Lag, C0=C0, K1 = C1 %*% M1 %*% inv_M2_sqrt, Omg = Omg, M1 = M1, inv_M2_sqrt = inv_M2_sqrt))
}


dlm = function(Y, X, Z, Lag){
# This function fits the DLM using the frequentist framework
#
# The inputs for this function are
# Y: the outcome, a vector of length n
# X: the matrix of size n x L of DL covariates (i.e., the covariate value within each ring-shaped area)
# Z: other covariates including intercept with size n x p
# Lag: a vector or distances r_1, r_2,..., r_L used to construct the DL covariates
#
# The outputs from this function are:
# thetas: parameter estimates for coefficients of Z, X*, and Z* in eAppendix
# cov_thetas: covariance matrix of estimates for coefficients of Z, X*, and Z* in eAppendix
# Table: summary table driven by "lme" function object.
# Lag: same as the input vector of Lag.
# betas_Z: parameter estimates for coefficients of other covariate Z
# cov_betas_Z: covariance matrix of betas_Z
# summary_betas_Z: summary table for other covariate Z (generated by "lme" function object).
# DL_coeff: estimated DL coefficients
# cov_DL_coeff: covariance matrix of DL_coeff
# summary_DL_coeff: estimated DL coefficients with their 95% confidence interval 

		L = length(Lag)
		Const = LagFunc(Lag)
		Y = as.matrix(Y); Z = as.matrix(Z); X = as.matrix(X);
		X_star = X %*% Const$C0; Z_star = X %*% Const$K1;
		D_star = cbind(Z, X_star, Z_star);

		n_z = ncol(Z);n_fix = ncol(X_star) + n_z; n_random = ncol(Z_star); n = length(Y)

		sub = rep(1, n)
		fit = lme(Y ~ -1 + Z + X_star, random=list(sub=pdIdent(~Z_star-1)))
		b1 =  unlist(fit$coef$random)
		thetas = c(fit$coef$fixed, b1)
		sigma_b_sq = (fit$sigma*exp(unlist(fit$modelStruct)))^2
		tau_sq = fit$sigma^2
		G = diag(c(rep(0, n_fix), rep(1/sigma_b_sq, n_random)))
		cov_thetas = solve(t(D_star) %*% D_star/tau_sq + G)
		
		#### estimated coefficients of other covariates (confounders) and their cov ####
		betas_Z = thetas[1:n_z]
		cov_betas_Z = cov_thetas[1:n_z, 1:n_z]
		summary_betas_Z = summary(fit)$tTable[1:n_z,]
		
		#### estimated DL coefficients and their cov ####
		cov_DL_coeff = Const$Omg %*% cov_thetas[-(1:n_z),-(1:n_z)] %*% t(Const$Omg)
		DL_coeff = Const$Omg %*% thetas[-(1:n_z)]
		CI_DL_coeff = cbind(DL_coeff -1.96*sqrt(diag(cov_DL_coeff)), DL_coeff + 1.96*sqrt(diag(cov_DL_coeff)))
		summary_DL_coeff = cbind(DL_coeff, CI_DL_coeff)
		colnames(summary_DL_coeff) = c("est", "2.5%", "97.5%")
		rownames(DL_coeff) = rownames(cov_DL_coeff) = colnames(cov_DL_coeff) = rownames(summary_DL_coeff) = Const$Lag
		return(list(thetas = thetas, cov_thetas = cov_thetas, Table = summary(fit), Lag = Const$Lag,
					betas_Z = betas_Z, cov_betas_Z = cov_betas_Z, summary_betas_Z = summary_betas_Z,
					DL_coeff = DL_coeff, cov_DL_coeff = cov_DL_coeff, summary_DL_coeff = summary_DL_coeff))
}


Bayes_dlm = function(Y, X, Z, Lag, n_sim = 5000, n_save = 1000, burn_in = 2000, per_print=1000, 
				prior_list = list(a_tau = .1, b_tau = 1e-6, a_sigma_b = .1, b_sigma_b = 1e-6),
				int_list = list(thetas = rep(0, length(Lag)+ncol(Z)), sigma_b_sq = .1)){
#
# This function fits the DLM using the Bayesian framework
#
# The inputs for this function are
# Y: the outcome, a vector of length n
# X: the matrix of size n x L of DL covariates (i.e., the covariate value within each ring-shaped area)
# Z: other covariates including intercept with size n x p
# Lag: a vector or distances r_1, r_2,..., r_L used to construct the DL covariates
# n_sim: number of iteration to sample posterior samples
# n_save: number of saved posterior samples after thinning
# burn_in: number of posterior samples in the burn-in period
# per_print: print the current number of simulation per input number. 
# sigma_b_sq: variance of random effects for smoothing spline.
# prior_list: hyper-prior value for tau^2 (variance of residuals), and sigma_b^2 (variance of random effects for smoothing spline).
# int_list: initial values for thetas and sigma_b_sq

#
# The outputs from this function are:
# post_thetas: posterior samples for coefficients of Z, X*, and Z* in eAppendix
# summary_thetas: posterior summaries of post_thetas (median, 95% credible interval)
# post_betas_Z: posterior samples for coefficients of Z
# summary_betas_Z: posterior summaries of post_betas_Z (median, 95% credible interval)
# post_tau_sq: posterior samples for variance of residual errors
# post_sigma_b_sq: posterior samples for variance of random effects for smoothing spline.
# post_DL_coeff: posterior samples for DL coefficients.
# summary_DL_coeff: posterior summaries of post_DL_coeff (median, 95% credible interval)
# DIC: Deviance information criterion
# Lag: same as the input vector of Lag.
#
       	L = length(Lag)		
		Const = LagFunc(Lag)
		Y = as.matrix(Y); Z = as.matrix(Z); X = as.matrix(X);
		X_star = X %*% Const$C0; Z_star = X %*% Const$K1;
		D_star = cbind(Z, X_star, Z_star);
		n_z = ncol(Z); n_fix = ncol(X_star) + n_z; n_random = ncol(Z_star);
		n_thetas = n_fix + n_random;n = length(Y);
		idx_ran = (n_fix+1):n_thetas
		thinning = floor((n_sim - burn_in)/n_save)
		save = kk = 1 

		post_tau_sq = post_sigma_b_sq = post_lb = rep(0, n_save);
		post_thetas = matrix(0, nrow = n_save, ncol = n_thetas)
		thetas = int_list$thetas; sigma_b_sq = int_list$sigma_b_sq
		G = diag(c(rep(0, n_fix), rep(1, n_random)))
		XX = t(D_star) %*% D_star; XY = t(D_star) %*% Y
		
		for(s in 1:n_sim){
			res = Y - D_star %*% thetas
			tau_sq = 1/rgamma(1, prior_list$a_tau + n/2, t(res) %*% res/2 + prior_list$b_tau)
			Sigma = solve(XX/tau_sq + G/sigma_b_sq)
			mu = Sigma%*%(XY/tau_sq)
			thetas = t(chol(Sigma)) %*% rnorm(n_thetas) + mu
			sigma_b_sq = 1/rgamma(1, prior_list$a_sigma_b + (L-2)/2, prior_list$b_sigma_b + t(thetas)%*%G%*%thetas/2)

			if(kk == s/per_print){
				print(paste("iteration #:", s))
				kk = kk+1
			}

			if(s > burn_in && s%%thinning == 0 && save <= n_save){
				res = Y - D_star %*% thetas
				post_thetas[save,] = thetas; post_tau_sq[save] = tau_sq; 
				post_sigma_b_sq[save] = sigma_b_sq; 
				post_lb[save] = n*log(tau_sq) + t(res) %*% res/tau_sq + n*log(2*pi) ## -2*log_likelihood
				save = save + 1
			}
		}

		#### DIC ####
		thetas_bar = colMeans(post_thetas)
		tau_sq_bar = mean(post_tau_sq)
		res = Y - D_star %*% thetas_bar
		D_bar = mean(post_lb)
		D_hat = n*log(tau_sq_bar) + t(res) %*% res/tau_sq_bar + n*log(2*pi)
		DIC = 2*D_bar - D_hat
		
		#### summary thetas ####
		summary_thetas = matrix(nrow = n_thetas, ncol = 3)
		for(i in 1:n_thetas) summary_thetas[i,] = quantile(post_thetas[,i], prob = c(0.5, 0.025, 0.975))
		rownames(summary_thetas) = c(paste("Z", 1:n_z, sep=""), "X_star1", "X_star2", paste("b", 1:n_random, sep=""))
		colnames(summary_thetas) = c("50%", "2.5%", "97.5%")		
		
		#### posterior samples and summary for coefficients of other covariates (confounders) ####
		post_betas_Z = post_thetas[, 1:n_z]
		summary_betas_Z = summary_thetas[1:n_z,]
		
		#### Transforming for posterior DL coefficients ####
		post_DL_coeff = matrix(nrow = n_save, ncol = L)
		for(s in 1:n_save) post_DL_coeff[s,] = Const$Omg %*% post_thetas[s,-(1:ncol(Z))]

		summary_DL_coeff = matrix(nrow = L, ncol = 3)
		for(i in 1:L) summary_DL_coeff[i,] = quantile(post_DL_coeff[,i], prob = c(0.5, 0.025, 0.975))
		rownames(summary_DL_coeff) = c(Const$Lag)
		colnames(summary_DL_coeff) = c("50%", "2.5%", "97.5%")
		
		return(list(post_thetas = post_thetas, summary_thetas=summary_thetas,
					post_betas_Z = post_betas_Z, summary_betas_Z = summary_betas_Z,
					post_tau_sq = post_tau_sq, post_sigma_b_sq = post_sigma_b_sq,
					post_DL_coeff = post_DL_coeff, summary_DL_coeff = summary_DL_coeff,  
					DIC = DIC, Lag = Const$Lag))
}


plot.dlm = function(dlm_object, ...){
			DL_coeff = dlm_object$summary_DL_coeff[,1]
			DL_coeff_LCI = dlm_object$summary_DL_coeff[,2]
			DL_coeff_UCI = dlm_object$summary_DL_coeff[,3]
			ylim = c(min(dlm_object$summary_DL_coeff), max(dlm_object$summary_DL_coeff))
			## plot the estimated DL coefficients ##
			Lag = rep(dlm_object$Lag, 3)
			plot(Lag, c(DL_coeff, DL_coeff_LCI, DL_coeff_UCI), ylab="DL coefficients", type="n", lwd=2, ...)
			lines(dlm_object$Lag, DL_coeff, lwd=2)
			lines(dlm_object$Lag, DL_coeff_LCI, lty=2, col="grey", lwd=2)
			lines(dlm_object$Lag, DL_coeff_UCI, lty=2, col="grey", lwd=2)
			abline(h = 0, lty=2, col="2")
}


#### Estimate DL coefficients at a certain distance ####
Bayes_DL_coeff_pred = function(Bayes_dlm_object, dist){
# This function estimates DL coefficients at a specified distance
#
# The inputs for this function are
# Bayes_dlm_object: an object from fitted "Bayes_dlm" function.
# dist: a scalar of a certain distance 
#
# The outputs from this function are:
# post_DL_coeff_pred: posterior sample for DL coefficient at a specified distance
# summary_DL_coeff_pred: posterior summaries of post_DL_coeff_pred (median, 95% credible interval)
#

	Lag = Bayes_dlm_object$Lag
	L = length(Lag); n_post = nrow(Bayes_dlm_object$post_thetas)
	Const = LagFunc(Lag)
	Lag_ct = Lag - mean(Lag)
	Lag_ct_pred = dist - mean(Lag)
	C0_pred = cbind(1, Lag_ct_pred)
	C1_pred = matrix(nrow = 1, ncol = L)
	n_z = ncol(Bayes_dlm_object$post_betas_Z)
	idx_lag = (n_z+1):(n_z+L)
	
	for(j in 1:L) C1_pred[1,j] = abs(Lag_ct[j] - Lag_ct_pred)^3
	Omg_pred = cbind(C0_pred, C1_pred %*% Const$M1 %*% Const$inv_M2_sqrt)
	
	post_DL_coeff_pred = matrix(nrow = n_post, ncol = 1)
	for(i in 1:n_post) post_DL_coeff_pred[i,] = Omg_pred %*% Bayes_dlm_object$post_thetas[i,idx_lag]
	summary_DL_coeff_pred = quantile(post_DL_coeff_pred, prob = c(0.5, 0.025, 0.975))
	
	return(list(post_DL_coeff_pred = post_DL_coeff_pred, summary_DL_coeff_pred = summary_DL_coeff_pred))
}


#### Estimate Average effects up to a certain distance ####
Bayes_avg_eff = function(Bayes_dlm_object, dist){
# This function estimates an average buffer effect up to a specified distance
#
# The inputs for this function are
# Bayes_dlm_object: an object from fitted "Bayes_dlm" function.
# dist: a scalar of a certain distance 
#
# The outputs from this function are:
# post_avg_eff: posterior sample for an average buffer effect up to a specified distance
# summary_avg_eff: posterior summaries of post_avg_eff (median, 95% credible interval)
#		
		Lag = Bayes_dlm_object$Lag
		Const = LagFunc(Lag)
		L = length(Lag)
		n_post = nrow(Bayes_dlm_object$post_thetas)
		
		if(min(Lag)<dist){
			idx_p = tail(which(Lag < dist), n=1)
			wts = pi*(c(Lag[1:idx_p], dist)^2 - c(0, Lag[1:idx_p])^2)/(pi*dist^2)
			tmp_beta = Bayes_DL_coeff_pred(Bayes_dlm_object,dist)$post_DL_coeff_pred
			avg_eff = rowSums(cbind(Bayes_dlm_object$post_DL_coeff[,1:idx_p], tmp_beta)*
							  matrix(wts, nrow = n_post, ncol=idx_p+1, byrow = T))
		}
		if(min(Lag)>=dist) avg_eff = c(Bayes_DL_coeff_pred(Bayes_dlm_object,dist)$post_DL_coeff_pred)
		
		summary_avg_eff = quantile(avg_eff, prob = c(0.5, 0.025, 0.975))
		return(list(post_avg_eff = avg_eff, summary_avg_eff = summary_avg_eff))							  
}



#### Estimate DL coefficients at a certain distance ####
DL_coeff_pred = function(dlm_object, dist){
# This function estimates DL coefficients at a specified distance
#
# The inputs for this function are
# dlm_object: an object from fitted "dlm" function.
# dist: a scalar of a certain distance.
#
# The outputs from this function are:
# DL_coeff_pred: point estimate for DL coefficient at a specified distance.
# var_DL_coeff_pred: variance of estimate for DL coefficient at a specified distance.
# summary_DL_coeff_pred: estimated DL coefficient with its 95% confidence interval 
#
	Lag = dlm_object$Lag
	L = length(Lag); 
	Const = LagFunc(Lag)
	Lag_ct = Lag - mean(Lag)
	Lag_ct_pred = dist - mean(Lag)
	C0_pred = cbind(1, Lag_ct_pred)
	C1_pred = matrix(nrow = 1, ncol = L)
	n_z = length(dlm_object$betas_Z)
	idx_lag = (n_z+1):(n_z+L)
	
	for(j in 1:L) C1_pred[1,j] = abs(Lag_ct[j] - Lag_ct_pred)^3
	Omg_pred = cbind(C0_pred, C1_pred %*% Const$M1 %*% Const$inv_M2_sqrt)
	DL_coeff_pred = Omg_pred %*% dlm_object$thetas[idx_lag]
	var_DL_coeff_pred = Omg_pred %*% dlm_object$cov_thetas[-(1:n_z),-(1:n_z)] %*% t(Omg_pred)
	CI_DL_coeff_pred = c(DL_coeff_pred -1.96*sqrt(var_DL_coeff_pred), DL_coeff_pred + 1.96*sqrt(var_DL_coeff_pred))
	summary_DL_coeff_pred = c(DL_coeff_pred, CI_DL_coeff_pred)
	names(summary_DL_coeff_pred) = c("est", "2.5%", "97.5%")
	
	return(list(DL_coeff_pred = DL_coeff_pred, var_DL_coeff_pred = var_DL_coeff_pred, 
				summary_DL_coeff_pred = summary_DL_coeff_pred))
}



#### Estimate Average effects up to a certain distance ####
Avg_eff = function(dlm_object, dist){
# This function estimates an average buffer effect up to a specified distance.
#
# The inputs for this function are
# dlm_object: an object from fitted "dlm" function.
# dist: a scalar of a certain distance.
#
# The outputs from this function are:
# avg_eff: point estimate for an average buffer effect up to a specified distance.
# var_avg_eff: variance of estimate for an average buffer effect up to a specified distance.
# summary_avg_eff: estimated average effect with its 95% confidence interval 
#
		Lag = dlm_object$Lag
		L = length(Lag); 
		Const = LagFunc(Lag)
		Lag_ct = Lag - mean(Lag)
		Lag_ct_pred = dist - mean(Lag)
		C0_pred = cbind(1, Lag_ct_pred)
		C1_pred = matrix(nrow = 1, ncol = L)
		n_z = length(dlm_object$betas_Z)
		idx_lag = (n_z+1):(n_z+L)
		for(j in 1:L) C1_pred[1,j] = abs(Lag_ct[j] - Lag_ct_pred)^3
		Omg_pred = cbind(C0_pred, C1_pred %*% Const$M1 %*% Const$inv_M2_sqrt)
		
		if(min(Lag)<dist){
			idx_p = tail(which(Lag < dist), n=1)
			Omg = rbind(Const$Omg[1:idx_p,], Omg_pred)
			DL_coeff = c(dlm_object$DL_coeff[1:idx_p], DL_coeff_pred(dlm_object,dist)$DL_coeff_pred)
			cov_DL_coeff = Omg %*% dlm_object$cov_thetas[-(1:n_z),-(1:n_z)] %*% t(Omg)
			wts = pi*(c(Lag[1:idx_p], dist)^2 - c(0, Lag[1:idx_p])^2)/(pi*dist^2)
			avg_eff = wts %*% DL_coeff
			var_avg_eff = wts %*% cov_DL_coeff %*% wts
			CI_avg_eff = c(avg_eff -1.96*sqrt(var_avg_eff), avg_eff + 1.96*sqrt(var_avg_eff))
			summary_avg_eff = c(avg_eff, CI_avg_eff)			
		}
		
		if(min(Lag)>=dist){
			avg_eff = DL_coeff_pred(dlm_object,dist)$DL_coeff_pred
			var_avg_eff = DL_coeff_pred(dlm_object,dist)$var_DL_coeff_pred
			summary_avg_eff = DL_coeff_pred(dlm_object,dist)$summary_DL_coeff_pred
		}
		names(summary_avg_eff) = c("est", "2.5%", "97.5%")
		return(list(avg_eff = avg_eff, var_avg_eff = var_avg_eff, summary_avg_eff = summary_avg_eff))							  
}


DL_X = function(pts_outcome, pts_X, Lag, unit="ED"){
# This function calculates distributed lag covariates using outcome locations, locations of X (e.g., convenience stores), and Lag.
#
# The inputs for this function are
# pts_outcome: a matrix form of locations of outcomes; (x, y) or (longitude, latitude)
# pts_X: a matrix form of locations of environmental factors (e.g., fast food restaurants, convenience stores); (x, y) or (longitude, latitude)
# Lag: a vector of distance lag; e.g., c(r_1, r_2, ..., r_L)
# unit: a unit of Lag. Options:"ED" is Euclidean distance, "km" is kilo-meter, or " "mile" is mile. 
#       km and mile are calculated with longitude and latitude.
#
# The outputs from this function are:
# X: DL covariate matrix

		## Calculate a distance between a school and all , otherPoints of stores ##
		pts_outcome = as.matrix(pts_outcome); pts_X = as.matrix(pts_X);
		n = nrow(pts_outcome)
		a_mile = 1.609344#km
		L = length(Lag)
		X = matrix(nrow = n, ncol = L)
		for(i in 1:n){
			if(unit=="ED") dist = spDistsN1(pts_X, pts_outcome[i,])
			if(unit=="km") dist = spDistsN1(pts_X, pts_outcome[i,], longlat=TRUE)
			if(unit=="mile") dist = spDistsN1(pts_X, pts_outcome[i,], longlat=TRUE)/a_mile
			
			X[i,1] = sum(dist <= Lag[1])
			## Count the number of pts within a ring-shaped area
			for(j in 2:L) X[i, j] = sum(dist > Lag[j-1] & dist <= Lag[j])	
		}
		return(X)
}












